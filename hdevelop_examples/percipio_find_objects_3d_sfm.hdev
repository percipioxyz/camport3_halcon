<?xml version="1.0" encoding="UTF-8"?>
<hdevelop file_version="1.2" halcon_version="19.11.0.0">
<procedure name="main">
<interface/>
<body>
<c as_id="image_acquisition" as_name="Image Acquisition 01" as_grp="[1,1]" as_ord="1">* Image Acquisition 01: Code generated by Image Acquisition 01</c>
<l>AcqName := 'Percipio'</l>
<c></c>
<l>info_framegrabber (AcqName, 'device', DeviceInfo, DeviceValues)</l>
<l>info_framegrabber (AcqName, 'camera_type', CameraTypeInfo, CameraTypeValues)</l>
<c></c>
<l>imageType := 'point3d_1280x960'             //choose rgb/depth/point3d/rgbp here</l>
<l>trigger   := 'false'</l>
<l>cameraType1:= CameraTypeValues[1]</l>
<l>deviceID1  := DeviceValues[1]</l>
<c></c>
<l>dev_open_window (0, 0, 640, 480, 'black', WindowHandle)</l>
<l>open_framegrabber ('Percipio', 0, 0, 0, 0, 0, 0, 'default', -1, imageType, -1, trigger, cameraType1, deviceID1, -1, -1, AcqHandle)</l>
<l>grab_image_start (AcqHandle, -1)</l>
<c></c>
<l>while (true)</l>
<l>    dev_set_window (WindowHandle)</l>
<l>    if (imageType = 'point3d_1280x960' or imageType = 'point3d_640x480' or imageType = 'point3d_320x240')</l>
<l>        grab_image_async (Image, AcqHandle, -1)   </l>
<l>        scale_image(Image,ImageScaled,0.001,0)</l>
<l>        *gen_rectangle1(rect,0,0,1280,960)</l>
<l>        *reduce_domain(ImageScaled,rect,ImageReduced)</l>
<c>        </c>
<l>        results:=0 </l>
<l>        *find_object_by_sfm_COPY_1 (ImageReduced, results)</l>
<l>        find_object_by_sfm (ImageScaled, results)</l>
<c>        </c>
<l>        if (results = 0)</l>
<l>            dev_open_window (0, 0, 640, 480, 'black', WindowHandle)</l>
<l>            set_display_font (WindowHandle, 20, 'mono', 'true', 'false')</l>
<l>            dev_disp_text ('No object found!', 'window', 160, 200, 'black', [], [])</l>
<l>            disp_continue_message (WindowHandle, 'black', 'true')</l>
<l>            stop ()</l>
<l>        endif</l>
<l>    endif</l>
<l>endwhile</l>
<c></c>
<l as_id="image_acquisition" as_name="Image Acquisition 01" as_grp="[4,1]" as_ord="1">close_framegrabber (AcqHandle)</l>
<l>dev_set_window (WindowHandle)</l>
<l>dev_close_window ()</l>
</body>
<docu id="main">
<parameters/>
</docu>
</procedure>
<procedure name="yuv">
<interface>
<oo>
<par name="Multichannel" base_type="iconic" dimension="0"/>
</oo>
<ic>
<par name="AcqHandle" base_type="ctrl" dimension="0"/>
</ic>
</interface>
<body>
<l>        grab_image_async (Image, AcqHandle, -1)</l>
<l>        decompose3(Image,Image1,Image2,Image3)</l>
<l>        trans_to_rgb(Image1,Image2,Image3,ImageRed,ImageGreen,ImageBlue,'yuv')</l>
<l>        compose3(ImageRed,ImageGreen,ImageBlue,Multichannel)</l>
<l>return ()</l>
</body>
<docu id="yuv">
<parameters>
<parameter id="AcqHandle"/>
<parameter id="Multichannel"/>
</parameters>
</docu>
</procedure>
<procedure name="depth">
<interface>
<oo>
<par name="ImageConverted" base_type="iconic" dimension="0"/>
</oo>
<ic>
<par name="AcqHandle" base_type="ctrl" dimension="0"/>
</ic>
</interface>
<body>
<l>        grab_image_async (Image, AcqHandle, -1)</l>
<l>        convert_image_type (Image, ImageConverted, 'real')</l>
<l>return ()</l>
</body>
<docu id="depth">
<parameters>
<parameter id="AcqHandle"/>
<parameter id="ImageConverted"/>
</parameters>
</docu>
</procedure>
<procedure name="gen_visualization_title">
<interface>
<ic>
<par name="BoxInformation" base_type="ctrl" dimension="0"/>
</ic>
<oc>
<par name="Title" base_type="ctrl" dimension="0"/>
</oc>
</interface>
<body>
<l>Is2DOnly := 1</l>
<l>get_dict_tuple (BoxInformation, 'results', BoxResult)</l>
<l>get_dict_param (BoxResult, 'keys', [], BoxIndices)</l>
<l>tuple_length (BoxIndices, BoxNumber)</l>
<l>if (BoxNumber==0)</l>
<l>    Title:=-1</l>
<l>    return()</l>
<l>endif</l>
<c>* </c>
<l>for Index := 1 to BoxNumber by 1</l>
<l>    get_dict_tuple (BoxResult, 0, BoxIndex)</l>
<l>    get_dict_tuple (BoxIndex, 'one_side_only', Is2D)</l>
<l>    if (Is2D != 'true')</l>
<l>        Is2DOnly := 0</l>
<l>    endif</l>
<l>endfor</l>
<c>* </c>
<l>if (Is2DOnly)</l>
<l>    Title := 'The visible side and the computed gripping pose are displayed for each box found.'</l>
<l>else</l>
<l>    Title := 'If more than one side of a box is visible, the box can be fully displayed.'</l>
<l>endif</l>
<l>return ()</l>
</body>
<docu id="gen_visualization_title">
<parameters>
<parameter id="BoxInformation"/>
<parameter id="Title"/>
</parameters>
</docu>
</procedure>
<procedure name="find_box_3d_surface">
<interface>
<io>
<par name="ImageXYZ" base_type="iconic" dimension="0"/>
</io>
<ic>
<par name="CameraParam" base_type="ctrl" dimension="0"/>
<par name="boxLength" base_type="ctrl" dimension="0"/>
<par name="boxWidth" base_type="ctrl" dimension="0"/>
<par name="boxHeight" base_type="ctrl" dimension="0"/>
<par name="minZ" base_type="ctrl" dimension="0"/>
<par name="maxZ" base_type="ctrl" dimension="0"/>
<par name="minScore" base_type="ctrl" dimension="0"/>
<par name="numBox" base_type="ctrl" dimension="0"/>
</ic>
<oc>
<par name="FindResults" base_type="ctrl" dimension="0"/>
</oc>
</interface>
<body>
<c>* Simple example for edge-supported surface-based matching.</c>
<c>* </c>
<c>* This example demonstrates how to use edge-supported surface-based</c>
<c>* matching, with and without images.</c>
<c>* </c>
<l>dev_update_off ()</l>
<c>* </c>
<c>* Parameters of the 2D camera.</c>
<l>*gen_cam_par_area_scan_division (0.003, -22215.7, 1e-6, 1e-6, 629.3, 486.95, 1280, 960, CameraParam)</l>
<c>* The camera is located in the origin of the 3D sensor.</c>
<l>create_pose (0, 0, 0, 0, 0, 0, 'Rp+T', 'gba', 'point', CameraPose)</l>
<l>*create_pose (-0.075, -0.56, 4.4, 308, 6, 335, 'Rp+T', 'gba', 'point', VisualizationPose)</l>
<l>VisualizationPose:=[]</l>
<l>get_cam_par_data (CameraParam, 'image_width', Width)</l>
<l>get_cam_par_data (CameraParam, 'image_height', Height)</l>
<l>dev_close_window ()</l>
<l>dev_open_window (0, 0, 1280 * 2 / 3, 960 * 2 / 3, 'black', WindowHandle)</l>
<l>set_display_font (WindowHandle, 16, 'mono', 'true', 'false')</l>
<l>Instructions := 'Rotate: Left button'</l>
<l>Instructions[1] := 'Zoom: Shift + left button'</l>
<l>Instructions[2] := 'Move: Ctrl + left button'</l>
<c>* </c>
<l>dev_disp_text ('This example demonstrates edge-supported surface-based matching', 'window', 12, 12, 'black', [], [])</l>
<c>* </c>
<c>* Create a 3D model of a box for surface-based matching.</c>
<l>gen_box_object_model_3d ([0,0,0,0,0,0,0], boxLength,boxWidth,boxHeight, ObjectModel3DBox)</l>
<l>triangulate_object_model_3d (ObjectModel3DBox, 'greedy', [], [], ObjectModel3DModel, Information)</l>
<c>* Prepare a model for edge-supported surface-based matching.</c>
<l>FileName := 'box_edge_supported_3.sfm'</l>
<l>file_exists (FileName, FileExists)</l>
<l>if (not FileExists)</l>
<l>    dev_disp_text ('No pre-created model found.\nCreating new surface model.\nThis may take some minutes...', 'window', 60, 12, 'black', [], [])</l>
<l>    create_surface_model (ObjectModel3DModel, 0.03, 'train_3d_edges', 'true', SurfaceModel)</l>
<l>    write_surface_model (SurfaceModel, FileName)</l>
<l>else</l>
<l>    dev_disp_text ('Pre-created model found.\nReading...', 'window', 60, 12, 'black', [], [])</l>
<l>    read_surface_model (FileName, SurfaceModel)</l>
<l>endif</l>
<l>dev_disp_text ('Press Run (F5) to continue', 'window', 'bottom', 'right', 'black', [], [])</l>
<l>stop ()</l>
<c>* </c>
<c>* Iterate over the scenes and visualize the matching results.</c>
<l>    decompose3 (ImageXYZ, XScene, YScene, ZScene)</l>
<l>    xyz_to_object_model_3d (XScene, YScene, ZScene, ObjectModel3DScene)</l>
<c>    * </c>
<l>        dev_set_lut ('default')</l>
<l>        *prepare_object_model_3d (ObjectModel3DScene, 'segmentation', 'true', [], [])</l>
<l>        visualize_object_model_3d (WindowHandle, ObjectModel3DScene, [], VisualizationPose, ['color_attrib','lut'], ['coord_z','inv_sqr'], '3D search scene with box', [], Instructions, VisualizationPose)</l>
<l>        *visualize_object_model_3d (WindowHandle, ObjectModel3DScene, [],[],[],[],[],[],[], VisualizationPose)</l>
<c>    * </c>
<c>    * Remove background plane. This improves both the robustness and the matching speed.</c>
<l>    select_points_object_model_3d (ObjectModel3DScene, 'point_coord_z', minZ, maxZ, ObjectModel3DSceneWithoutBackground)</l>
<c>    * </c>
<c>    * Use edge-supported surface-based matching to find the boxes.</c>
<l>    set_surface_model_param (SurfaceModel, 'clear_cameras', [])</l>
<l>    count_seconds (T0)</l>
<l>    find_surface_model (SurfaceModel, ObjectModel3DSceneWithoutBackground, 0.05, 0.1, minScore, 'false', ['num_matches','pose_ref_sub_sampling'], [numBox,10], Pose, Score, SurfaceMatchingResultID)</l>
<l>    count_seconds (T1)</l>
<c>    * </c>
<c>    * Visualize the results in 3D for the first scene.</c>
<l>        rigid_trans_object_model_3d (ObjectModel3DModel, Pose, ObjectModel3DRigidTrans)</l>
<l>        dev_set_lut ('default')</l>
<l>        visualize_object_model_3d (WindowHandle, [ObjectModel3DScene,ObjectModel3DRigidTrans], [], VisualizationPose, ['alpha','color','color_0','color_attrib_0','lut_0'], [0.8,'green','white','coord_z','inv_sqr'], 'Box found with edge-supported surface-based matching', [], Instructions, PoseOut)</l>
<c>    * </c>
<c>    * Visualize the matching results in the Z-Image.</c>
<l>    object_model_3d_to_xyz (X, Y, Z, ObjectModel3DScene, 'from_xyz_map', [], [])</l>
<l>    dev_clear_window ()</l>
<l>    dev_set_lut ('inv_sqr')</l>
<l>    dev_display (Z)</l>
<l>    gen_empty_obj (AllContours)</l>
<l>    for Index := 0 to |Score| - 1 by 1</l>
<l>        CurrPose := Pose[7 * Index:7 * Index + 6]</l>
<l>        project_object_model_3d (Contours, ObjectModel3DModel, CameraParam, CurrPose, [], [])</l>
<l>        concat_obj (AllContours, Contours, AllContours)</l>
<l>        get_center_contour_xlds (Contours, CenterRow, CenterCol)</l>
<l>        dev_disp_text ('Score = ' + Score[Index]$'.2f', 'image', CenterRow, CenterCol - 70, 'black', [], [])</l>
<l>    endfor</l>
<c>    * </c>
<l>    dev_set_color ('yellow')</l>
<l>    dev_set_line_width (2)</l>
<l>    dev_display (AllContours)</l>
<l>    dev_disp_text (['Matching results with edge-supported surface-based matching','Time for matching: ' + ((T1 - T0) * 1000)$'.0f' + ' ms'], 'window', 12, 12, 'black', [], [])</l>
<l>    dev_disp_text ('Press Run (F5) to continue', 'window', 'bottom', 'right', 'black', [], [])</l>
<l>    stop ()</l>
<c>    * </c>
<c>    * Use edge-supported surface-based matching to find the box, including an image of the scene</c>
<c>    * that is used for refinement.</c>
<l>*     set_surface_model_param (SurfaceModel, 'camera_parameter', CameraParam)</l>
<l>*     set_surface_model_param (SurfaceModel, 'camera_pose', CameraPose)</l>
<l>*     count_seconds (T0)</l>
<l>*     find_surface_model_image (Image, SurfaceModel, ObjectModel3DSceneWithoutBackground, 0.05, 0.1, 0.2, 'false', ['num_matches','pose_ref_sub_sampling'], [3,10], PoseWithImage, ScoreWithImage, SurfaceMatchingResultID)</l>
<l>*     count_seconds (T1)</l>
<c>    * </c>
<c>    * Visualize the results by projecting them into the image.</c>
<l>*     dev_set_lut ('default')</l>
<l>*     gen_empty_obj (AllContours)</l>
<l>*     for Index := 0 to |ScoreWithImage| - 1 by 1</l>
<l>*         CurrPose := PoseWithImage[7 * Index:7 * Index + 6]</l>
<l>*         project_object_model_3d (Contours, ObjectModel3DModel, CameraParam, CurrPose, [], [])</l>
<l>*         concat_obj (AllContours, Contours, AllContours)</l>
<l>*         get_center_contour_xlds (Contours, CenterRow, CenterCol)</l>
<l>*         dev_disp_text ('Score = ' + ScoreWithImage[Index]$'.2f', 'image', CenterRow, CenterCol - 70, 'black', [], [])</l>
<l>*     endfor</l>
<l>*     dev_set_color ('green')</l>
<l>*     dev_display (AllContours)</l>
<l>*     dev_disp_text (['Matching results with edge-supported surface-based matching and a 2D image','Time for matching: ' + ((T1 - T0) * 1000)$'.0f' + ' ms'], 'window', 12, 12, 'black', [], [])</l>
<c></c>
<l>*         dev_disp_text ('Press Run (F5) to continue', 'window', 'bottom', 'right', 'black', [], [])</l>
<c></c>
<l>*     stop ()</l>
<l>    return()</l>
</body>
<docu id="find_box_3d_surface">
<parameters>
<parameter id="CameraParam"/>
<parameter id="FindResults"/>
<parameter id="ImageXYZ"/>
<parameter id="boxHeight"/>
<parameter id="boxLength"/>
<parameter id="boxWidth"/>
<parameter id="maxZ"/>
<parameter id="minScore"/>
<parameter id="minZ"/>
<parameter id="numBox"/>
</parameters>
</docu>
</procedure>
<procedure name="wrap_text">
<interface>
<ic>
<par name="Text" base_type="ctrl" dimension="0"/>
<par name="MaxLineLength" base_type="ctrl" dimension="0"/>
</ic>
<oc>
<par name="TextWrapped" base_type="ctrl" dimension="0"/>
</oc>
</interface>
<body>
<l>TextWrapped := regexp_replace(Text + ' ',['(.{0,' + MaxLineLength + '})\\s','replace_all'],'$1\n')</l>
<l>return ()</l>
</body>
<docu id="wrap_text">
<parameters>
<parameter id="MaxLineLength"/>
<parameter id="Text"/>
<parameter id="TextWrapped"/>
</parameters>
</docu>
</procedure>
<procedure name="get_center_contour_xlds">
<interface>
<io>
<par name="Contours" base_type="iconic" dimension="0"/>
</io>
<oc>
<par name="CenterRow" base_type="ctrl" dimension="0"/>
<par name="CenterCol" base_type="ctrl" dimension="0"/>
</oc>
</interface>
<body>
<l>count_obj (Contours, Number)</l>
<l>MinRow := []</l>
<l>MaxRow := []</l>
<l>MinCol := []</l>
<l>MaxCol := []</l>
<l>for Index := 1 to Number by 1</l>
<l>    select_obj (Contours, ObjectSelected, Index)</l>
<l>    get_contour_xld (ObjectSelected, Row, Col)</l>
<l>    MinRow := min([MinRow,Row])</l>
<l>    MaxRow := max([MaxRow,Row])</l>
<l>    MinCol := min([MinCol,Col])</l>
<l>    MaxCol := max([MaxCol,Col])</l>
<l>endfor</l>
<l>CenterRow := MinRow + 0.5 * (MaxRow - MinRow)</l>
<l>CenterCol := MinCol + 0.5 * (MaxCol - MinCol)</l>
<l>return ()</l>
</body>
<docu id="get_center_contour_xlds">
<parameters>
<parameter id="CenterCol">
<default_type>real</default_type>
<sem_type>point.x</sem_type>
<type_list>
<item>real</item>
</type_list>
</parameter>
<parameter id="CenterRow">
<default_type>real</default_type>
<sem_type>point.y</sem_type>
<type_list>
<item>real</item>
</type_list>
</parameter>
<parameter id="Contours">
<sem_type>xld_cont</sem_type>
</parameter>
</parameters>
</docu>
</procedure>
<procedure name="find_object_3d_bgSubstract">
<interface>
<io>
<par name="depth" base_type="iconic" dimension="0"/>
<par name="p3d" base_type="iconic" dimension="0"/>
<par name="color" base_type="iconic" dimension="0"/>
</io>
<oo>
<par name="outMask" base_type="iconic" dimension="0"/>
</oo>
<ic>
<par name="param" base_type="ctrl" dimension="0"/>
</ic>
</interface>
<body>
<c></c>
<l>return ()</l>
</body>
<docu id="find_object_3d_bgSubstract">
<parameters>
<parameter id="color"/>
<parameter id="depth"/>
<parameter id="outMask"/>
<parameter id="p3d"/>
<parameter id="param"/>
</parameters>
</docu>
</procedure>
<procedure name="find_box_3d_surface_m">
<interface>
<io>
<par name="ImageXYZ" base_type="iconic" dimension="0"/>
</io>
<ic>
<par name="CameraParam" base_type="ctrl" dimension="0"/>
</ic>
<oc>
<par name="Results" base_type="ctrl" dimension="0"/>
</oc>
</interface>
<body>
<c>* Example for edge-supported surface-based matching</c>
<c>* </c>
<c>* This example demonstrates how to use edge-supported surface-based</c>
<c>* matching. I shows, how to cope with edges stemming from the boundary</c>
<c>* of the scene, how to speed up the matching, and how to use</c>
<c>* images as an additional source of information.</c>
<c>* </c>
<l>dev_update_off ()</l>
<c>* </c>
<c>* Parameters of the 2D camera.</c>
<l>*gen_cam_par_area_scan_division (0.003, -22215.7, 1e-6, 1e-6, 629.3, 486.95, 1280, 960, CameraParam)</l>
<l>get_cam_par_data (CameraParam, 'image_width', Width)</l>
<l>get_cam_par_data (CameraParam, 'image_height', Height)</l>
<c>* The camera is located in the origin of the 3D sensor.</c>
<l>create_pose (0, 0, 0, 0, 0, 0, 'Rp+T', 'gba', 'point', CameraPose)</l>
<c>* Matching parameters.</c>
<l>MinScore := 0.05</l>
<c>* Visualization parameters.</c>
<l>create_pose (-0.075, -0.56, 4.4, 308, 6, 335, 'Rp+T', 'gba', 'point', VisPose)</l>
<l>VisParamNames := ['color','color_0','alpha','alpha_0']</l>
<l>VisParamValues := ['red','white',0.5,1]</l>
<l>WidthW1 := 400</l>
<l>LineLength := 32</l>
<l>VisRowNextStep := 300</l>
<l>VisInstructions[0] := 'Rotate: Left button'</l>
<l>VisInstructions[1] := 'Zoom:   Shift + left button'</l>
<l>VisInstructions[2] := 'Move:   Ctrl  + left button'</l>
<c>* Prepare windows.</c>
<l>dev_close_window ()</l>
<l>dev_open_window_fit_size (0, WidthW1 + 10, Width, Height, 640, 480, WindowHandle2)</l>
<l>get_window_extents (WindowHandle2, Row, Column, WidthW2, HeightW2)</l>
<l>dev_open_window (0, 0, WidthW1, HeightW2, 'white', WindowHandle1)</l>
<l>set_display_font (WindowHandle1, 16, 'mono', 'true', 'false')</l>
<l>set_display_font (WindowHandle2, 16, 'mono', 'true', 'false')</l>
<c>* </c>
<c>* Read image of the scene.</c>
<l>*SceneIdx := 4</l>
<l>*read_image (Image, 'boxes/cardboard_boxes_02')</l>
<c>* </c>
<c>* Display first message and the image of the scene.</c>
<l>dev_set_window (WindowHandle1)</l>
<l>dev_clear_window ()</l>
<l>Text := 'This example demonstrates edge-supported surface-based matching. The goal is to find cardboard boxes in 3D scans of the scene.'</l>
<l>wrap_text (Text, LineLength, TextWrapped)</l>
<l>dev_disp_text (TextWrapped, 'window', 'top', 'left', 'black', 'box', 'false')</l>
<l>dev_set_window (WindowHandle2)</l>
<l>*dev_display (Image)</l>
<c>* </c>
<c>* Create a 3D model of a box.</c>
<l>dev_set_window (WindowHandle1)</l>
<l>gen_box_object_model_3d ([0,0,0,0,0,0,0], 0.245, 0.2, 0.18, ObjectModel3DBox)</l>
<l>triangulate_object_model_3d (ObjectModel3DBox, 'greedy', [], [], ObjectModel3DModel, Information)</l>
<c>* Prepare a model for edge-supported surface-based matching.</c>
<l>FileName := 'box_edge_supported.sfm'</l>
<l>file_exists (FileName, FileExists)</l>
<l>if (not FileExists)</l>
<l>    dev_disp_text ('Creating new surface model.\nThis might take some minutes...', 'window', 150, 'left', 'black', 'box', 'false')</l>
<l>    create_surface_model (ObjectModel3DModel, 0.03, 'train_3d_edges', 'true', SurfaceModel)</l>
<l>    write_surface_model (SurfaceModel, FileName)</l>
<l>else</l>
<l>    dev_disp_text ('Reading pre-created surface model...', 'window', 150, 'left', 'black', 'box', 'false')</l>
<l>    read_surface_model (FileName, SurfaceModel)</l>
<l>endif</l>
<c>* </c>
<c>* Read the 3D object model of the search scene and prepare it for display.</c>
<l>*read_image (ImageXYZ, 'boxes/cardboard_boxes_xyz_02')</l>
<l>decompose3 (ImageXYZ, XScene, YScene, ZScene)</l>
<l>xyz_to_object_model_3d (XScene, YScene, ZScene, ObjectModel3DScene)</l>
<l>prepare_object_model_3d (ObjectModel3DScene, 'segmentation', 'true', [], [])</l>
<l>get_object_model_3d_params (ObjectModel3DScene, 'center', VisRotationCenter)</l>
<c>* </c>
<c>* Display search scene.</c>
<l>dev_set_window (WindowHandle1)</l>
<l>Text := 'First, let\'s have a look at the 3D data of the scene.'</l>
<l>wrap_text (Text, LineLength, TextWrapped)</l>
<l>dev_disp_text (TextWrapped, 'window', VisRowNextStep, 'left', 'black', 'box', 'false')</l>
<l>dev_disp_text ('Press Run (F5) to continue', 'window', 'bottom', 'right', 'black', [], [])</l>
<l>stop ()</l>
<l>dev_clear_window ()</l>
<l>Text := 'In the 3D data, the two boxes appear as planar parts that lie clearly above the ground plane.'</l>
<l>wrap_text (Text, LineLength, TextWrapped)</l>
<l>dev_disp_text (TextWrapped, 'window', 'top', 'left', 'black', 'box', 'false')</l>
<l>visualize_object_model_3d (WindowHandle2, ObjectModel3DScene, [], VisPose, [], [], '3D scene', [], VisInstructions, VisPose)</l>
<c>* </c>
<c>* Show results of surface-based matching without edge support.</c>
<l>dev_set_window (WindowHandle1)</l>
<l>dev_clear_window ()</l>
<l>Text := 'Objects with a planar surface are sometimes found incorrectly if no edge information is used. Especially, if the surface of the object in the search scene is fragmented, e.g., because of reflections on the surface.'</l>
<l>wrap_text (Text, LineLength, TextWrapped)</l>
<l>dev_disp_text (TextWrapped, 'window', 'top', 'left', 'black', 'box', 'false')</l>
<c>* Perform surface-based matching without edge support.</c>
<l>find_surface_model (SurfaceModel, ObjectModel3DScene, 0.05, 0.1, MinScore, 'false', ['num_matches','use_3d_edges'], [1,'false'], Pose, Score, SurfaceMatchingResult)</l>
<c>* Display results.</c>
<l>rigid_trans_object_model_3d (ObjectModel3DModel, Pose, ObjectModel3DRigidTrans)</l>
<l>visualize_object_model_3d (WindowHandle2, [ObjectModel3DScene,ObjectModel3DRigidTrans], [], VisPose, VisParamNames, VisParamValues, 'Without edge support, a wrong match is found.', [], VisInstructions, VisPose)</l>
<c>* </c>
<c>* Show results of edge-supported surface-based matching.</c>
<l>dev_set_window (WindowHandle1)</l>
<l>dev_clear_window ()</l>
<l>Text := 'In those cases, the use of 3D edges (displayed in green) helps to find the correct match. Note that \'num_matches\' has been set to 1, therefore only one box is found.'</l>
<l>wrap_text (Text, LineLength, TextWrapped)</l>
<l>dev_disp_text (TextWrapped, 'window', 'top', 'left', 'black', 'box', 'false')</l>
<l>Text := 'To use edge-supported surface-based matching, create the surface model with the generic parameter \'train_3d_edges\' set to \'true\'.'</l>
<l>wrap_text (Text, LineLength, TextWrapped)</l>
<l>dev_disp_text (TextWrapped, 'window', 150, 'left', 'black', 'box', 'false')</l>
<c>* Perform edge-supported surface-based matching.</c>
<l>find_surface_model (SurfaceModel, ObjectModel3DScene, 0.05, 0.1, MinScore, 'false', 'num_matches', 1, Pose, Score, SurfaceMatchingResult)</l>
<c>* Extract edges for visualization.</c>
<l>get_object_model_3d_params (ObjectModel3DScene, 'diameter_axis_aligned_bounding_box', Diameter)</l>
<l>edges_object_model_3d (ObjectModel3DScene, 0.01 * Diameter, [], [], ObjectModel3DEdges)</l>
<c>* Display results.</c>
<l>rigid_trans_object_model_3d (ObjectModel3DModel, Pose, ObjectModel3DRigidTrans)</l>
<l>VisParamValues[0] := 'forest green'</l>
<l>visualize_object_model_3d (WindowHandle2, [ObjectModel3DScene,ObjectModel3DEdges,ObjectModel3DRigidTrans], [], VisPose, [VisParamNames,'color_1'], [VisParamValues,'green'], 'With edge support, the match is found correctly.', [], VisInstructions, VisPose)</l>
<c>* </c>
<c>* Show results of edge-supported surface-based matching when searching for multiple matches.</c>
<l>dev_set_window (WindowHandle1)</l>
<l>dev_clear_window ()</l>
<l>Text := 'If we search for more than one match, the second box is found as well.'</l>
<l>wrap_text (Text, LineLength, TextWrapped)</l>
<l>dev_disp_text (TextWrapped, 'window', 'top', 'left', 'black', 'box', 'false')</l>
<l>Text := 'Note that additional matches may also be found in the corners of the 3D scene. The top plane of the box fits perfectly to the background plane of the scene and two of the top plane\'s edges match the 3D edges of the scene.'</l>
<l>wrap_text (Text, LineLength, TextWrapped)</l>
<l>dev_disp_text (TextWrapped, 'window', 150, 'left', 'black', 'box', 'false')</l>
<c>* Perform edge-supported surface-based matching.</c>
<l>find_surface_model (SurfaceModel, ObjectModel3DScene, 0.05, 0.1, MinScore, 'false', 'num_matches', 5, Pose, Score, SurfaceMatchingResult)</l>
<c>* Display results.</c>
<l>rigid_trans_object_model_3d (ObjectModel3DModel, Pose, ObjectModel3DRigidTrans)</l>
<l>visualize_object_model_3d (WindowHandle2, [ObjectModel3DScene,ObjectModel3DEdges,ObjectModel3DRigidTrans], [], VisPose, [VisParamNames,'color_1','color_4'], [VisParamValues,'green','red'], 'The boundaries of the scene lead to additional matches.', [], VisInstructions, VisPose)</l>
<c>* </c>
<c>* Show how to remove edges at the boundary of the scene if the 3D object model has mapping information.dev_set_window (WindowHandle1)</c>
<l>dev_set_window (WindowHandle1)</l>
<l>dev_clear_window ()</l>
<l>Text := 'We can eliminate the 3D edges stemming from the boundary of the scene (displayed in red) to avoid the additional matches in the corners of the scene.'</l>
<l>wrap_text (Text, LineLength, TextWrapped)</l>
<l>dev_disp_text (TextWrapped, 'window', 'top', 'left', 'black', 'box', 'false')</l>
<c>* Eliminate 3D edges at the boundary of the scene.</c>
<l>Border := 50</l>
<l>object_model_3d_to_xyz (XEdges, YEdges, ZEdges, ObjectModel3DEdges, 'from_xyz_map', [], [])</l>
<l>get_image_size (XEdges, WidthMapping, HeightMapping)</l>
<l>select_points_object_model_3d (ObjectModel3DEdges, ['mapping_row','mapping_col'], [Border,Border], [HeightMapping - Border,WidthMapping - Border], ObjectModel3DEdgesWithoutBorder)</l>
<c>* Display results.</c>
<l>visualize_object_model_3d (WindowHandle2, [ObjectModel3DEdgesWithoutBorder,ObjectModel3DEdges], [], VisPose, ['color_0','color_1'], ['green','red'], 'Scene edges with removed edges at the boundary', [], VisInstructions, VisPose)</l>
<c>* </c>
<c>* Show results of edge-supported surface-based matching when using manipulated 3D edges.</c>
<l>dev_set_window (WindowHandle1)</l>
<l>dev_clear_window ()</l>
<l>Text := 'Without the edges at the boundary of the scene, no additional matches are found in the corners of the scene.'</l>
<l>wrap_text (Text, LineLength, TextWrapped)</l>
<l>dev_disp_text (TextWrapped, 'window', 'top', 'left', 'black', 'box', 'false')</l>
<l>Text := 'You can modify the 3D edges in any way. To use modified edges, they must be given as value of the generic parameter \'3d_edges\' of the operator find_surface_model.'</l>
<l>wrap_text (Text, LineLength, TextWrapped)</l>
<l>dev_disp_text (TextWrapped, 'window', 150, 'left', 'black', 'box', 'false')</l>
<c>* Perform edge-supported surface-based matching.</c>
<l>find_surface_model (SurfaceModel, ObjectModel3DScene, 0.05, 0.1, MinScore, 'false', ['num_matches','3d_edges'], [5,ObjectModel3DEdgesWithoutBorder], Pose, Score, SurfaceMatchingResult)</l>
<c>* Display results.</c>
<l>rigid_trans_object_model_3d (ObjectModel3DModel, Pose, ObjectModel3DRigidTrans)</l>
<l>visualize_object_model_3d (WindowHandle2, [ObjectModel3DScene,ObjectModel3DEdgesWithoutBorder,ObjectModel3DRigidTrans], [], VisPose, [VisParamNames,'color_1'], [VisParamValues,'green'], 'Matching result with cropped edges', [], VisInstructions, VisPose)</l>
<c>* </c>
<c>* Show how to remove the background plane from the scene.</c>
<l>dev_set_window (WindowHandle1)</l>
<l>dev_clear_window ()</l>
<l>Text := 'An even better way to avoid matches in the background plane is to completely remove the background plane from the scene.'</l>
<l>wrap_text (Text, LineLength, TextWrapped)</l>
<l>dev_disp_text (TextWrapped, 'window', 'top', 'left', 'black', 'box', 'false')</l>
<l>Text := 'This is sometimes not possible, but if it is, you should do it!'</l>
<l>wrap_text (Text, LineLength, TextWrapped)</l>
<l>dev_disp_text (TextWrapped, 'window', 150, 'left', 'black', 'box', 'false')</l>
<c>* Remove the background plane from the scene.</c>
<l>select_points_object_model_3d (ObjectModel3DScene, 'point_coord_z', 0.1, 0.73, SceneWithoutBackground)</l>
<c>* Display results.</c>
<l>rigid_trans_object_model_3d (ObjectModel3DModel, Pose, ObjectModel3DRigidTrans)</l>
<l>visualize_object_model_3d (WindowHandle2, [SceneWithoutBackground,ObjectModel3DScene], [], VisPose, ['color_0','color_1','alpha_1'], ['white','red',0.5], 'Scene and removed background', [], VisInstructions, VisPose)</l>
<l>dev_set_window (WindowHandle2)</l>
<l>dev_clear_window ()</l>
<c>* </c>
<c>* Show results of edge-supported surface-based matching when using a scene without the background plane.</c>
<l>dev_set_window (WindowHandle1)</l>
<l>dev_clear_window ()</l>
<l>Text := 'Without the background plane of the scene, no additional matches are found in the corners of the scene. Furthermore, the matching is significantly faster if the background has been removed from the scene.'</l>
<l>wrap_text (Text, LineLength, TextWrapped)</l>
<l>dev_disp_text (TextWrapped, 'window', 'top', 'left', 'black', 'box', 'false')</l>
<l>dev_disp_text ('Determining speedup...', 'window', 200, 'left', 'black', 'box', 'false')</l>
<c>* Determine speedup.</c>
<l>Num := 5</l>
<l>count_seconds (S1)</l>
<l>for I := 1 to Num by 1</l>
<l>    find_surface_model (SurfaceModel, ObjectModel3DScene, 0.05, 0.1, MinScore, 'false', 'num_matches', 3, Pose, Score, SurfaceMatchingResult)</l>
<l>endfor</l>
<l>count_seconds (S2)</l>
<l>TimeWithBackground := (S2 - S1) / real(Num) * 1000.0</l>
<l>count_seconds (S1)</l>
<l>for I := 1 to Num by 1</l>
<l>    find_surface_model (SurfaceModel, SceneWithoutBackground, 0.05, 0.1, MinScore, 'false', 'num_matches', 3, Pose, Score, SurfaceMatchingResult)</l>
<l>endfor</l>
<l>count_seconds (S2)</l>
<l>TimeNoBackground := (S2 - S1) / real(Num) * 1000.0</l>
<c>* </c>
<l>Text[0] := 'Runtime:'</l>
<l>Text[1] := '  With background:    ' + TimeWithBackground$'4.0f' + ' ms'</l>
<l>Text[2] := '  Without background: ' + TimeNoBackground$'4.0f' + ' ms'</l>
<l>dev_disp_text (Text, 'window', 250, 'left', 'black', 'box', 'false')</l>
<c>* Display results.</c>
<l>edges_object_model_3d (SceneWithoutBackground, 0.01 * Diameter, [], [], ObjectModel3DEdgesWithoutBackground)</l>
<l>rigid_trans_object_model_3d (ObjectModel3DModel, Pose, ObjectModel3DRigidTrans)</l>
<l>visualize_object_model_3d (WindowHandle2, [SceneWithoutBackground,ObjectModel3DEdgesWithoutBackground,ObjectModel3DRigidTrans], [], VisPose, [VisParamNames,'color_1'], [VisParamValues,'green'], 'Matching result in scene with removed background', [], VisInstructions, VisPose)</l>
<c>* </c>
<c>* Speedup edge-supported surface-based matching by reducing the number of points used for pose refinement.</c>
<l>dev_set_window (WindowHandle1)</l>
<l>dev_clear_window ()</l>
<l>Text := 'Further speedup is possible, if the points in the search scene are dense compared to the size of the object, i.e., if the pose refinement has to use a large number of points.'</l>
<l>wrap_text (Text, LineLength, TextWrapped)</l>
<l>dev_disp_text (TextWrapped, 'window', 'top', 'left', 'black', 'box', 'false')</l>
<l>Text := 'The number of points used for the pose refinement can be reduced by increasing the generic parameter \'pose_ref_sub_sampling\'. '</l>
<l>wrap_text (Text, LineLength, TextWrapped)</l>
<l>dev_disp_text (TextWrapped, 'window', 150, 'left', 'black', 'box', 'false')</l>
<l>dev_disp_text ('Determining speedup...', 'window', 270, 'left', 'black', 'box', 'false')</l>
<c>* Determine speedup.</c>
<l>Num := 5</l>
<l>count_seconds (S1)</l>
<l>for I := 1 to Num by 1</l>
<l>    find_surface_model (SurfaceModel, ObjectModel3DScene, 0.05, 0.1, MinScore, 'false', ['num_matches','pose_ref_sub_sampling'], [3,20], Pose, Score, SurfaceMatchingResult)</l>
<l>endfor</l>
<l>count_seconds (S2)</l>
<l>TimeWithBackgroundPoseRefSubSampling := (S2 - S1) / real(Num) * 1000.0</l>
<l>count_seconds (S1)</l>
<l>for I := 1 to Num by 1</l>
<l>    find_surface_model (SurfaceModel, SceneWithoutBackground, 0.05, 0.1, MinScore, 'false', ['num_matches','pose_ref_sub_sampling'], [3,20], Pose, Score, SurfaceMatchingResult)</l>
<l>endfor</l>
<l>count_seconds (S2)</l>
<l>TimeNoBackgroundPoseRefSubSampling := (S2 - S1) / real(Num) * 1000.0</l>
<c>* </c>
<l>Text[0] := 'Runtime:'</l>
<l>Text[1] := '  pose_ref_sub_sampling = 2 (default):'</l>
<l>Text[2] := '    With background:    ' + TimeWithBackground$'4.0f' + ' ms'</l>
<l>Text[3] := '    Without background: ' + TimeNoBackground$'4.0f' + ' ms'</l>
<l>Text[4] := '  pose_ref_sub_sampling = 20:'</l>
<l>Text[5] := '    With background:    ' + TimeWithBackgroundPoseRefSubSampling$'4.0f' + ' ms'</l>
<l>Text[6] := '    Without background: ' + TimeNoBackgroundPoseRefSubSampling$'4.0f' + ' ms'</l>
<l>dev_disp_text (Text, 'window', 300, 'left', 'black', 'box', 'false')</l>
<c>* Display results.</c>
<l>rigid_trans_object_model_3d (ObjectModel3DModel, Pose, ObjectModel3DRigidTrans)</l>
<l>visualize_object_model_3d (WindowHandle2, [SceneWithoutBackground,ObjectModel3DEdgesWithoutBackground,ObjectModel3DRigidTrans], [], VisPose, [VisParamNames,'color_1'], [VisParamValues,'green'], 'Matching result in scene with pose_ref_sub_sampling = 20', [], VisInstructions, VisPose)</l>
<c>* </c>
<c>* Show results of edge-supported surface-based matching with use of image edges.</c>
<l>* dev_set_window (WindowHandle1)</l>
<l>* dev_clear_window ()</l>
<l>* Text := 'You can even use image data to improve the matching results. This is especially helpful if the 3D edges from the scene are blurry or distorted. The typically better defined image edges improve the matching accuracy.'</l>
<l>* wrap_text (Text, LineLength, TextWrapped)</l>
<l>* dev_disp_text (TextWrapped, 'window', 'top', 'left', 'black', 'box', 'false')</l>
<l>* Text := 'To use image edges, use the operator find_surface_model_image.'</l>
<l>* wrap_text (Text, LineLength, TextWrapped)</l>
<l>* dev_disp_text (TextWrapped, 'window', 200, 'left', 'black', 'box', 'false')</l>
<c>* Perform edge-supported surface-based matching.</c>
<l>* set_surface_model_param (SurfaceModel, 'camera_parameter', CameraParam)</l>
<l>* set_surface_model_param (SurfaceModel, 'camera_pose', CameraPose)</l>
<l>* find_surface_model_image (Image, SurfaceModel, SceneWithoutBackground, 0.05, 0.1, MinScore, 'true', ['num_matches','pose_ref_sub_sampling'], [5,20], Pose, Score, SurfaceMatchingResult)</l>
<c>* Display results.</c>
<l>* rigid_trans_object_model_3d (ObjectModel3DModel, Pose, ObjectModel3DRigidTrans)</l>
<c>* Get gray values from image.</c>
<l>* object_model_3d_to_xyz (X, Y, Z, SceneWithoutBackground, 'from_xyz_map', [], [])</l>
<l>* get_domain (Z, Domain)</l>
<l>* get_region_points (Domain, Rows, Columns)</l>
<l>* get_grayval (Image, Rows, Columns, AttribValues)</l>
<c>* Set the gray values as attributes of the 3D object model.</c>
<l>* set_object_model_3d_attrib_mod (SceneWithoutBackground, '&amp;gray', 'points', AttribValues)</l>
<l>* visualize_object_model_3d (WindowHandle2, [SceneWithoutBackground,ObjectModel3DEdgesWithoutBackground,ObjectModel3DRigidTrans], [], VisPose, [VisParamNames,'color_1','color_attrib_0'], [VisParamValues,'green','&amp;gray'], 'Matching result with 2D and 3D edge support', ['','',Score], VisInstructions, VisPose)</l>
<c>* Display results on image.</c>
<l>* set_window_param (WindowHandle2, 'flush', 'false')</l>
<l>* dev_set_lut ('cubic_root')</l>
<l>* dev_set_line_width (3)</l>
<l>* dev_set_color ('green')</l>
<l>* dev_display (Image)</l>
<l>* dev_disp_text ('Matching results projected into the image', 'window', 'top', 'left', 'black', [], [])</l>
<l>* for Index := 0 to |Score| - 1 by 1</l>
<l>*     CurrPose := Pose[7 * Index:7 * Index + 6]</l>
<l>*     project_object_model_3d (Contours, ObjectModel3DModel, CameraParam, CurrPose, [], [])</l>
<l>*     dev_display (Contours)</l>
<c>    * Display Scores</c>
<l>*     get_surface_matching_result (SurfaceMatchingResult, 'score', Index, ScoreTotal)</l>
<l>*     get_surface_matching_result (SurfaceMatchingResult, 'score_surface', Index, ScoreSurface)</l>
<l>*     get_surface_matching_result (SurfaceMatchingResult, 'score_3d_edges', Index, Score3DEdges)</l>
<l>*     get_surface_matching_result (SurfaceMatchingResult, 'score_2d_edges', Index, Score2DEdges)</l>
<l>*     ScoresText := ['Total Score:   ' + ScoreTotal$'.2','Surface Score: ' + ScoreSurface$'.2','3D Edge Score: ' + Score3DEdges$'.2','2D Edge Score: ' + Score2DEdges$'.2']</l>
<l>*     get_surface_model_param (SurfaceModel, 'center', Center)</l>
<l>*     pose_to_hom_mat3d (CurrPose, HomMat3D)</l>
<l>*     affine_trans_point_3d (HomMat3D, Center[0], Center[1], Center[2], Qx, Qy, Qz)</l>
<l>*     project_3d_point (Qx, Qy, Qz, CameraParam, Row, Column)</l>
<c>    * </c>
<l>*     dev_disp_text (ScoresText, 'image', Row - 100, Column - 100, 'black', [], [])</l>
<l>* endfor</l>
<l>* dev_set_line_width (1)</l>
<l>* flush_buffer (WindowHandle2)</l>
<l>* set_window_param (WindowHandle2, 'flush', 'true')</l>
<c>* </c>
<l>* dev_set_window (WindowHandle2)</l>
<l>* dev_disp_text ('      End of program      ', 'window', 'bottom', 'right', 'black', [], [])</l>
<l>* stop ()</l>
<c>* </c>
<l>dev_set_lut ('default')</l>
<l>return ()</l>
</body>
<docu id="find_box_3d_surface_m">
<parameters>
<parameter id="CameraParam"/>
<parameter id="ImageXYZ"/>
<parameter id="Results"/>
</parameters>
</docu>
</procedure>
<procedure name="find_object_by_sfm">
<interface>
<io>
<par name="ImageXYZ" base_type="iconic" dimension="0"/>
</io>
<ic>
<par name="Results" base_type="ctrl" dimension="0"/>
</ic>
</interface>
<body>
<c>* ***********************************************************************</c>
<c>* Example for Surface-Based 3D Matching</c>
<c>* </c>
<c>* This example shows Surface-Based 3D Matching on data taken with a</c>
<c>* Time-of-flight camera (TOF/PMD).</c>
<c>* The model for the matching is created from a reference view of the</c>
<c>* object, i.e., no CAD model is used.</c>
<c>* The created model is then searched for in a number of 3D scenes.</c>
<c>* </c>
<c>* The example demonstrates how to use the operators</c>
<c>*   xyz_to_object_model_3d,</c>
<c>*   create_surface_model, and</c>
<c>*   find_surface_model.</c>
<c>* </c>
<c>* ***********************************************************************</c>
<c>* </c>
<c>* Initialization</c>
<c>* Display the model</c>
<l>Instructions[0] := 'Rotate: Left button'</l>
<l>Instructions[1] := 'Zoom:   Shift + left button'</l>
<l>Instructions[2] := 'Move:   Ctrl  + left button'</l>
<l>dev_update_off ()</l>
<l>gen_empty_obj (EmptyObject)</l>
<l>ImagePath := 'time_of_flight/'</l>
<l>dev_close_window ()</l>
<l>FileNameSurface := 'surface.sfm'</l>
<l>FileNameObject := 'object.om3'</l>
<l>file_exists (FileNameSurface, FileExists)</l>
<l>if (not FileExists)</l>
<l>    dev_disp_text ('No pre-created model found.\nCreating new surface model.\nThis may take some minutes...', 'window', 60, 12, 'black', [], [])</l>
<c>    * </c>
<c>    * ***********************************************************************</c>
<c>    * Offline-Phase: Model generation from a reference XYZ Image</c>
<c>    * ***********************************************************************</c>
<c>    * </c>
<c>    * Load the XYZ images with the reference object</c>
<c></c>
<l>    decompose3 (ImageXYZ, Xm, Ym, Zm)</l>
<c>    * Remove the background plane</c>
<l>    threshold (Zm, ModelZ, 0.60, 0.65)</l>
<c>    * Find connected regions</c>
<l>    connection (ModelZ, ConnectedModel)</l>
<c>    * Select the regions for the ROI of the reference model</c>
<l>    select_obj (ConnectedModel, ModelROI, [2])</l>
<l>    union1 (ModelROI, ModelROI)</l>
<c>    * Create the ROI</c>
<l>    reduce_domain (Xm, ModelROI, Xm)</l>
<c></c>
<c>    * </c>
<c>    * Display model image and ROI</c>
<l>    dev_open_window_fit_image (Zm, 0, 0, -1, -1, WindowHandle)</l>
<l>    set_display_font (WindowHandle, 14, 'mono', 'true', 'false')</l>
<c></c>
<l>    dev_display (Zm)</l>
<l>    dev_set_line_width (2)</l>
<l>    dev_set_draw ('margin')</l>
<l>    dev_set_color ('green')</l>
<l>    dev_display (ModelROI)</l>
<l>    disp_message (WindowHandle, 'Create surface model from XYZ image region', 'window', 12, 12, 'black', 'true')</l>
<l>    disp_continue_message (WindowHandle, 'black', 'true')</l>
<l>    stop ()</l>
<l>    dev_clear_window ()</l>
<c></c>
<c>    * </c>
<c>    * Create the surface model from the reference view</c>
<l>    xyz_to_object_model_3d (Xm, Ym, Zm, ObjectModel3DModel)</l>
<l>    create_surface_model (ObjectModel3DModel, 0.03, [], [], SFM)</l>
<l>    write_surface_model (SFM, FileNameSurface)</l>
<l>    write_object_model_3d (ObjectModel3DModel, 'om3', FileNameObject, [], [])</l>
<c></c>
<l>    Message := 'Surface model'</l>
<l>    visualize_object_model_3d (WindowHandle, ObjectModel3DModel, [], [], [], [], Message, [], Instructions, PoseOut)</l>
<l>else</l>
<l>    dev_disp_text ('Pre-created model found.\nReading...', 'window', 60, 12, 'black', [], [])</l>
<l>    read_surface_model (FileNameSurface, SFM)</l>
<l>    read_object_model_3d (FileNameObject, 'm', [], [], ObjectModel3DModel, Status)</l>
<l>endif</l>
<l>*return()</l>
<c></c>
<c>* ***********************************************************************</c>
<c>* Online-Phase: Match the reference object in 3D scenes</c>
<c>* ***********************************************************************</c>
<c>* </c>
<c></c>
<c>    * ***************************************</c>
<c>    * Acquire scene</c>
<c>    * ***************************************</c>
<c>    * Load the XYZ Images</c>
<l>    decompose3 (ImageXYZ, X, Y, Z)</l>
<c>    * Remove the background plane to increase the speed and</c>
<c>    * robustness of the surface-based matching</c>
<l>    *threshold (Z, SceneGood, 0.6, 0.7)</l>
<l>    *reduce_domain (X, SceneGood, XReduced)</l>
<l>    *xyz_to_object_model_3d (XReduced, Y, Z, ObjectModel3DSceneReduced)</l>
<c>     </c>
<l>    xyz_to_object_model_3d (ImageXYZ, Y, Z, ObjectModel3DSceneReduced)</l>
<c>    * </c>
<c>    * ***************************************</c>
<c>    * Match: Find the reference model in the</c>
<c>    *        3D scene</c>
<c>    * ***************************************</c>
<l>    count_seconds (T0)</l>
<l>    find_surface_model (SFM, ObjectModel3DSceneReduced, 0.05, 0.3, 0.8, 'true', 'num_matches', 10, Pose, Score, SurfaceMatchingResultID)</l>
<l>    count_seconds (T1)</l>
<l>    if(|Score|==0)</l>
<l>        return()</l>
<l>    endif</l>
<l>    TimeForMatching := (T1 - T0) * 1000</l>
<c>    * </c>
<c>    * ***************************************</c>
<c>    * Display: Visualize the result(s)</c>
<c>    * ***************************************</c>
<c>    * Prepare the visualization of the result(s)</c>
<l>    ObjectModel3DResult := []</l>
<l>    for Index2 := 0 to |Score| - 1 by 1</l>
<l>        if (Score[Index2] &lt; 0.11)</l>
<l>            continue</l>
<l>        endif</l>
<l>        CPose := Pose[Index2 * 7:Index2 * 7 + 6]</l>
<c>        * </c>
<l>        rigid_trans_object_model_3d (ObjectModel3DModel, CPose, ObjectModel3DRigidTrans)</l>
<l>        ObjectModel3DResult := [ObjectModel3DResult,ObjectModel3DRigidTrans]</l>
<l>    endfor</l>
<c>    * </c>
<l>    xyz_to_object_model_3d (X, Y, Z, ObjectModel3DScene)</l>
<c>    * </c>
<c>    * Visualize matching scene and key points</c>
<l>    Message := 'Original scene points (white)'</l>
<l>    Message[1] := 'Sampled scene points (cyan)'</l>
<l>    Message[2] := 'Key points (yellow)'</l>
<l>    get_surface_matching_result (SurfaceMatchingResultID, 'sampled_scene', [], SampledScene)</l>
<l>    get_surface_matching_result (SurfaceMatchingResultID, 'key_points', [], KeyPoints)</l>
<l>    dev_clear_window ()</l>
<l>    dev_open_window_fit_image (ImageXYZ, 0, 0, -1, -1, WindowHandle)</l>
<l>    visualize_object_model_3d (WindowHandle, [ObjectModel3DScene,SampledScene,KeyPoints], [], [], ['color_' + [0,1,2],'point_size_' + [0,1,2]], ['gray','cyan','yellow',1.0,3.0,5.0], Message, [], Instructions, PoseOut)</l>
<c>    * </c>
<c>    * Visualize result(s)</c>
<l>    Message := 'Scene: ' </l>
<l>    Message[1] := 'Found ' + |ObjectModel3DResult| + ' object(s) in ' + TimeForMatching$'.3' + ' ms'</l>
<l>    ScoreString := sum(Score$'.2f' + ' / ')</l>
<l>    Message[2] := 'Score(s): ' + ScoreString{0:strlen(ScoreString) - 4}</l>
<l>    NumResult := |ObjectModel3DResult|</l>
<l>    tuple_gen_const (NumResult, 'green', Colors)</l>
<l>    tuple_gen_const (NumResult, 'circle', Shapes)</l>
<l>    tuple_gen_const (NumResult, 3, Radii)</l>
<l>    Indices := [1:NumResult]</l>
<c>    * </c>
<l>    dev_clear_window ()</l>
<l>    visualize_object_model_3d (WindowHandle, [ObjectModel3DScene,ObjectModel3DResult], [], PoseOut, ['color_' + [0,Indices],'point_size_0'], ['gray',Colors,1.0], Message, [], Instructions, PoseOut)</l>
<l>return ()</l>
</body>
<docu id="find_object_by_sfm">
<parameters>
<parameter id="ImageXYZ"/>
<parameter id="Results"/>
</parameters>
</docu>
</procedure>
<procedure name="find_object_by_sfm_COPY_1">
<interface>
<io>
<par name="ImageXYZ" base_type="iconic" dimension="0"/>
</io>
<ic>
<par name="Results" base_type="ctrl" dimension="0"/>
</ic>
</interface>
<body>
<c>* ***********************************************************************</c>
<c>* Example for Surface-Based 3D Matching</c>
<c></c>
<c>* This example shows Surface-Based 3D Matching on data taken with a</c>
<c>* Time-of-flight camera (TOF/PMD).</c>
<c>* The model for the matching is created from a reference view of the</c>
<c>* object, i.e., no CAD model is used.</c>
<c>* The created model is then searched for in a number of 3D scenes.</c>
<c></c>
<c>* The example demonstrates how to use the operators</c>
<c>*   xyz_to_object_model_3d,</c>
<c>*   create_surface_model, and</c>
<c>*   find_surface_model.</c>
<c></c>
<c>* ***********************************************************************</c>
<c></c>
<c>* Initialization</c>
<c>* Display the model</c>
<l>Instructions[0] := 'Rotate: Left button'</l>
<l>Instructions[1] := 'Zoom:   Shift + left button'</l>
<l>Instructions[2] := 'Move:   Ctrl  + left button'</l>
<l>dev_update_off ()</l>
<l>gen_empty_obj (EmptyObject)</l>
<l>ImagePath := 'time_of_flight/'</l>
<l>dev_close_window ()</l>
<l>FileName := 'object_.sfm'</l>
<l>FileName2 := 'object_.om3'</l>
<l>file_exists (FileName, FileExists)</l>
<l>if (not FileExists)</l>
<l>    dev_disp_text ('No pre-created model found.\nCreating new surface model.\nThis may take some minutes...', 'window', 60, 12, 'black', [], [])</l>
<c></c>
<c>    * ***********************************************************************</c>
<c>    * Offline-Phase: Model generation from a reference XYZ Image</c>
<c>    * ***********************************************************************</c>
<c></c>
<c>    * Load the XYZ images with the reference object</c>
<l>    decompose3 (ImageXYZ, Xm, Ym, Zm)</l>
<c>    * Remove the background plane</c>
<l>    threshold (Zm, ModelZ, 0.60, 0.65)</l>
<c>    * Find connected regions</c>
<l>    connection (ModelZ, ConnectedModel)</l>
<c>    * Select the regions for the ROI of the reference model</c>
<l>    select_obj (ConnectedModel, ModelROI, [1])</l>
<l>    union1 (ModelROI, ModelROI)</l>
<c>    * Create the ROI</c>
<l>    reduce_domain (Xm, ModelROI, Xm)</l>
<c></c>
<c>    * Display model image and ROI</c>
<l>dev_open_window_fit_image (Zm, 0, 0, -1, -1, WindowHandle)</l>
<l>set_display_font (WindowHandle, 14, 'mono', 'true', 'false')</l>
<l>    dev_display (Zm)</l>
<l>    dev_set_line_width (2)</l>
<l>    dev_set_draw ('margin')</l>
<l>    dev_set_color ('green')</l>
<l>    dev_display (ModelROI)</l>
<l>disp_message (WindowHandle, 'Create surface model from XYZ image region', 'window', 12, 12, 'black', 'true')</l>
<l>disp_continue_message (WindowHandle, 'black', 'true')</l>
<l>    stop ()</l>
<l>    dev_clear_window ()</l>
<c></c>
<c>    * Create the surface model from the reference view</c>
<l>    xyz_to_object_model_3d (Xm, Ym, Zm, ObjectModel3DModel)</l>
<l>    create_surface_model (ObjectModel3DModel, 0.03, [], [], SFM)</l>
<l>    write_surface_model (SFM, FileName)</l>
<l>    write_object_model_3d (ObjectModel3DModel, 'om3', FileName2, [], [])</l>
<c></c>
<l>    Message := 'Surface model'</l>
<l>visualize_object_model_3d (WindowHandle, ObjectModel3DModel, [], [], [], [], Message, [], Instructions, PoseOut)</l>
<c></c>
<l>else</l>
<l>    dev_disp_text ('Pre-created model found.\nReading...', 'window', 60, 12, 'black', [], [])</l>
<l>    read_surface_model (FileName, SFM)</l>
<l>    read_object_model_3d (FileName2, 'm', [], [], ObjectModel3DModel, Status)</l>
<l>endif</l>
<l>* return ()</l>
<c></c>
<c>* ***********************************************************************</c>
<c>* Online-Phase: Match the reference object in 3D scenes</c>
<c>* ***********************************************************************</c>
<c></c>
<c></c>
<c>* ***************************************</c>
<c>* Acquire scene</c>
<c>* ***************************************</c>
<c>* Load the XYZ Images</c>
<l>decompose3 (ImageXYZ, X, Y, Z)</l>
<c>* Remove the background plane to increase the speed and</c>
<c>* robustness of the surface-based matching</c>
<l>threshold (Z, SceneGood, 0.6, 0.7)</l>
<l>reduce_domain (X, SceneGood, XReduced)</l>
<l>xyz_to_object_model_3d (XReduced, Y, Z, ObjectModel3DSceneReduced)</l>
<c></c>
<c>* ***************************************</c>
<c>* Match: Find the reference model in the</c>
<c>*        3D scene</c>
<c>* ***************************************</c>
<l>count_seconds (T0)</l>
<l>find_surface_model (SFM, ObjectModel3DSceneReduced, 0.05, 0.3, 0.8, 'true', 'num_matches', 10, Pose, Score, SurfaceMatchingResultID)</l>
<l>count_seconds (T1)</l>
<l>if (|Score|==0)</l>
<l>    return ()</l>
<l>endif</l>
<l>TimeForMatching := (T1 - T0) * 1000</l>
<c></c>
<c>* ***************************************</c>
<c>* Display: Visualize the result(s)</c>
<c>* ***************************************</c>
<c>* Prepare the visualization of the result(s)</c>
<l>ObjectModel3DResult := []</l>
<l>for Index2 := 0 to |Score| - 1 by 1</l>
<l>    if (Score[Index2] &lt; 0.11)</l>
<l>        continue</l>
<l>    endif</l>
<l>    CPose := Pose[Index2 * 7:Index2 * 7 + 6]</l>
<c></c>
<l>    rigid_trans_object_model_3d (ObjectModel3DModel, CPose, ObjectModel3DRigidTrans)</l>
<l>    ObjectModel3DResult := [ObjectModel3DResult,ObjectModel3DRigidTrans]</l>
<l>endfor</l>
<c></c>
<l>xyz_to_object_model_3d (X, Y, Z, ObjectModel3DScene)</l>
<c></c>
<c>* Visualize matching scene and key points</c>
<l>Message := 'Original scene points (white)'</l>
<l>Message[1] := 'Sampled scene points (cyan)'</l>
<l>Message[2] := 'Key points (yellow)'</l>
<l>get_surface_matching_result (SurfaceMatchingResultID, 'sampled_scene', [], SampledScene)</l>
<l>get_surface_matching_result (SurfaceMatchingResultID, 'key_points', [], KeyPoints)</l>
<l>dev_clear_window ()</l>
<l>dev_open_window_fit_image (ImageXYZ, 0, 0, -1, -1, WindowHandle)</l>
<l>visualize_object_model_3d (WindowHandle, [ObjectModel3DScene,SampledScene,KeyPoints], [], [], ['color_' + [0,1,2],'point_size_' + [0,1,2]], ['gray','cyan','yellow',1.0,3.0,5.0], Message, [], Instructions, PoseOut)</l>
<c></c>
<c>* Visualize result(s)</c>
<l>Message := 'Scene: '</l>
<l>Message[1] := 'Found ' + |ObjectModel3DResult| + ' object(s) in ' + TimeForMatching$'.3' + ' ms'</l>
<l>ScoreString := sum(Score$'.2f' + ' / ')</l>
<l>Message[2] := 'Score(s): ' + ScoreString{0:strlen(ScoreString) - 4}</l>
<l>NumResult := |ObjectModel3DResult|</l>
<l>tuple_gen_const (NumResult, 'green', Colors)</l>
<l>tuple_gen_const (NumResult, 'circle', Shapes)</l>
<l>tuple_gen_const (NumResult, 3, Radii)</l>
<l>Indices := [1:NumResult]</l>
<c></c>
<l>dev_clear_window ()</l>
<l>visualize_object_model_3d (WindowHandle, [ObjectModel3DScene,ObjectModel3DResult], [], PoseOut, ['color_' + [0,Indices],'point_size_0'], ['gray',Colors,1.0], Message, [], Instructions, PoseOut)</l>
<c></c>
<l>return ()</l>
</body>
<docu id="find_object_by_sfm_COPY_1">
<parameters>
<parameter id="ImageXYZ"/>
<parameter id="Results"/>
</parameters>
</docu>
</procedure>
</hdevelop>
